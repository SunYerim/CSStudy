## Transaction

- **트랜잭션**: 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위.
- **상태 변화**: SQL 질의어를 통해 DB에 접근하는 것.
  - `SELECT`
  - `INSERT`
  - `DELETE`
  - `UPDATE`
- **작업 단위**: 여러 SQL 명령문들을 특정 기준에 따라 묶어 하나의 작업 단위로 정의.

### 트랜잭션 예시

사용자 A가 사용자 B에게 만원을 송금하는 경우:
1. 사용자 A의 계좌에서 만원을 차감한다 (`UPDATE` 문을 사용해 사용자 A의 잔고를 변경).
2. 사용자 B의 계좌에 만원을 추가한다 (`UPDATE` 문을 사용해 사용자 B의 잔고를 변경).

위 두 작업(출금 및 입금)은 하나의 트랜잭션으로 간주된다. 
이 두 쿼리문 모두 성공적으로 완료되어야만 하나의 트랜잭션이 완료된 것으로 간주하며, 이때 **Commit**이 발생한다. 
만약 쿼리 중 하나라도 실패하면 모든 쿼리문을 취소하고 이전 상태로 되돌려야 하며, 이를 **Rollback**이라고 한다.

## 트랜잭션의 특징 (ACID 특성)

1. **원자성 (Atomicity)**: 
   - 트랜잭션이 DB에 모두 반영되거나, 전혀 반영되지 않아야 한다.

2. **일관성 (Consistency)**: 
   - 트랜잭션의 작업 처리 결과는 항상 일관성을 유지해야 한다.

3. **독립성 (Isolation)**: 
   - 둘 이상의 트랜잭션이 동시에 실행될 때, 각각의 트랜잭션은 다른 트랜잭션의 영향을 받아서는 안 된다.

4. **지속성 (Durability)**: 
   - 트랜잭션이 성공적으로 완료되었으면, 그 결과는 영구적으로 DB에 반영되어야 한다.

## Commit과 Rollback

### Commit
- 트랜잭션이 성공적으로 끝나고, DB가 일관성 있는 상태로 유지될 때 이를 영구적으로 반영하기 위해 사용하는 연산.

### Rollback
- 트랜잭션 처리가 비정상적으로 종료되어 원자성이 깨진 경우, 트랜잭션 시작 전 상태로 되돌리기 위해 사용하는 연산. 이는 DB의 일관성을 유지하기 위해 매우 중요하다.

## Transaction 관리를 위한 DBMS의 전략

### DBMS의 구조
- **Query Processor (질의 처리기)** 와 **Storage System (저장 시스템)** 으로 크게 나뉜다.
- 데이터의 입출력은 고정 길이의 페이지 단위로 디스크에서 읽거나 쓰는 방식으로 이루어진다.
- 데이터는 비휘발성 저장 장치인 디스크에 저장되며, 그 일부가 메인 메모리에 저장된다.

### Page Buffer Manager
- DBMS의 Storage System에 속하는 모듈로, 메인 메모리에 유지되는 페이지를 관리한다.
- 버퍼 관리 정책에 따라 UNDO 복구와 REDO 복구가 필요할 수 있으며, 이는 트랜잭션 관리에서 매우 중요한 결정이다.

### UNDO와 REDO

#### UNDO
- **필요성**: 수정된 페이지들이 버퍼 교체 알고리즘에 따라 디스크에 기록될 수 있다. 버퍼 교체는 트랜잭션과 무관하게 버퍼 상태에 따라 결정되므로, 비정상적으로 종료된 트랜잭션이 변경한 페이지들은 원상 복구해야 한다.
- **버퍼 관리 정책**:
  - **Steal**: 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책.
   대부분의 DBMS가 이 정책을 채택하며, UNDO 로그와 복구가 필요하다.
  - **No-Steal**: 수정된 페이지들을 트랜잭션 종료 시점까지 버퍼에 유지하는 정책. 이 경우 UNDO 작업이 필요하지 않지만, 큰 메모리 버퍼가 필요하다.

#### REDO
- **필요성**: 이미 커밋된 트랜잭션의 수정을 재반영하는 복구 작업.
- **버퍼 관리 정책**:
  - **Force**: 수정된 모든 페이지를 트랜잭션 커밋 시점에 디스크에 반영하는 정책. 이 경우 REDO 복구가 필요하지 않다.
  - **No-Force**: 커밋 시점에 페이지를 디스크에 반영하지 않는 정책. 이 경우 트랜잭션이 디스크에 반영되지 않을 수 있어 REDO 복구가 필요하다. 대부분의 DBMS가 이 정책을 사용한다.

### 트랜잭션의 격리 수준 (Isolation Levels)
- **Read Uncommitted**: 커밋되지 않은 변경 사항도 읽을 수 있다.
- **Read Committed**: 커밋된 변경 사항만 읽을 수 있다.
- **Repeatable Read**: 트랜잭션 동안 읽은 데이터는 트랜잭션이 완료될 때까지 일관되게 유지된다.
- **Serializable**: 트랜잭션이 완전히 직렬화된 것처럼 실행되어, 동시 실행 시 발생할 수 있는 모든 문제를 방지한다.

### 트랜잭션 관리의 성능 고려사항
- **Locking**: 데이터에 대한 동시 접근을 제어하기 위한 방법으로, 트랜잭션의 독립성을 보장한다.
- **Deadlock**: 두 개 이상의 트랜잭션이 서로의 자원을 기다리며 무한히 대기하는 상황을 처리하기 위한 전략과 알고리즘이 필요하다.


## 면접 예상 질문
### 1. 트랜잭션의 ACID 특성에 대해 설명하고, 각 특성이 왜 중요한지 예를 들어 설명해보세요.
- 원자성 (Atomicity): 트랜잭션의 모든 작업이 성공하거나 모두 실패해야 하는 이유.
- 일관성 (Consistency): 데이터베이스의 무결성을 유지하기 위해 필요한 이유.
- 독립성 (Isolation): 동시성 제어에서 중요하며, 트랜잭션 간의 간섭을 방지해야 하는 이유.
- 지속성 (Durability): 트랜잭션이 완료된 후에도 결과가 영구적으로 유지되어야 하는 이유.

### 2. Commit과 Rollback의 차이점은 무엇이며, 각각을 언제 사용해야 하나요?
- Commit: 트랜잭션이 성공적으로 완료된 후, DB 상태를 영구적으로 반영할 때 사용하는 이유.
- Rollback: 트랜잭션이 실패하거나 중단된 경우, DB를 원래 상태로 되돌려야 하는 이유.
