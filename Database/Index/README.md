# DB Index

## 1. Index란 무엇인가?

- **목적**: RDBMS에서 검색 속도를 높이기 위한 기술입니다.
- **기능**: Table의 특정 Column을 색인화하여, 데이터를 빠르게 검색할 수 있도록 돕습니다.
- **작동 원리**: 색인화된 컬럼을 이용해 별도의 Index 파일을 생성하고, 검색 시 전체 데이터를 탐색하는 대신 Index 파일을 검색하여 성능을 향상시킵니다.

  - 해당 Table의 Record를 전체 탐색하지 않음.
  - 색인화 된 (B+ Tree 구조로) Index 파일 검색으로 검색 속도 향상.

## 2. Index 파일의 구성

- **Table 생성 시 파일 구성**:
  - `FRM`: 테이블 구조가 저장되어 있는 파일.
  - `MYD`: 실제 데이터가 저장된 파일.
  - `MYI`: Index 정보가 들어있는 파일.
  
- **Index 생성 전후의 차이**:
  - Index를 사용하지 않는 경우, `MYI` 파일은 비어있습니다.
  - Index를 생성한 후, `MYI` 파일이 생성되며, 이후 Select 쿼리에서 Index를 사용하는 컬럼을 탐색할 때 `MYI` 파일의 내용을 검색합니다.

## 3. Index의 장단점

### 3.1. 장점

- **검색 성능 향상**: 테이블의 전체 레코드를 검색하지 않고, 인덱스를 이용하여 필요한 데이터를 빠르게 검색할 수 있습니다.
- **중복 방지**: Primary Key나 Unique Index의 경우, 중복된 데이터를 방지할 수 있습니다.
- **정렬 속도 향상**: 정렬된 결과를 빠르게 얻을 수 있습니다.

### 3.2. 단점

- **저장 공간 증가**: 인덱스 파일이 생성되면서 추가적인 저장 공간이 필요합니다.
- **쓰기 성능 저하**: 데이터를 삽입, 수정, 삭제할 때마다 인덱스를 업데이트해야 하므로 쓰기 작업의 성능이 저하될 수 있습니다.
- **병행성 문제**: 한 페이지를 동시에 수정할 수 있는 병행성이 줄어듭니다.
- **인덱스 유지 비용**: 인덱스된 필드에서 데이터가 자주 변경되면, 인덱스를 재작성해야 하므로 성능에 영향을 미칩니다.

## 4. Index를 사용하면 좋은 경우

- **Where 절에서 자주 사용되는 Column**: 검색 조건으로 자주 사용되는 컬럼에 인덱스를 생성하면 성능이 향상됩니다.
- **외래키가 사용되는 Column**: 외래키 제약 조건이 걸린 컬럼에 인덱스를 생성하면, 조인(Join) 시 성능이 향상됩니다.
- **Join에 자주 사용되는 Column**: 테이블 간의 조인 조건으로 자주 사용되는 컬럼에 인덱스를 생성하면 성능이 향상됩니다.

## 5. Index 사용을 피해야 하는 경우

- **Data 중복도가 높은 Column**: 중복된 데이터가 많은 컬럼에 인덱스를 생성하면, 인덱스의 효과가 떨어질 수 있습니다.
- **DML이 자주 일어나는 Column**: 데이터 삽입, 수정, 삭제가 빈번한 컬럼에 인덱스를 생성하면, 인덱스를 유지하는 비용이 증가하여 성능에 악영향을 미칠 수 있습니다.

## 6. Index의 자료구조

### 6.1. B+ Tree Index

#### 개요

- **B+ Tree**는 대부분의 RDBMS에서 기본적으로 사용하는 Index 구조입니다.
- **구조**: B+ Tree는 Balanced Tree(균형 트리)의 일종으로, 각 노드가 여러 개의 자식을 가질 수 있으며, 모든 리프 노드가 동일한 깊이를 가집니다.
- **동작 원리**: 데이터를 삽입, 삭제, 검색할 때 B+ Tree는 데이터를 정렬된 상태로 유지하며, 트리의 깊이가 낮아 검색 및 삽입이 매우 효율적입니다.

#### 장점

- **범위 검색**: B+ Tree는 정렬된 상태로 데이터를 유지하므로, 특정 범위 내의 데이터를 빠르게 검색할 수 있습니다.
- **순차 접근 효율성**: 리프 노드들이 연결 리스트 형태로 연결되어 있어, 순차적인 데이터 접근이 효율적입니다.
- **성능 안정성**: 트리의 높이가 낮아지도록 균형을 유지하므로, 데이터의 검색, 삽입, 삭제 시 성능이 안정적으로 유지됩니다.

#### 단점

- **추가적인 저장 공간**: 트리 구조를 유지하기 위해 추가적인 저장 공간이 필요합니다.
- **복잡한 유지 관리**: 삽입과 삭제 시 트리의 균형을 유지하기 위한 작업이 필요하므로, 구현이 상대적으로 복잡합니다.
- **랜덤 접근 시 성능 저하**: 데이터가 매우 분산되어 있거나, 랜덤 접근이 많은 경우 성능이 다소 저하될 수 있습니다.

#### 사용하면 좋은 경우

- **범위 검색이 필요한 경우**: `WHERE` 절에서 특정 범위의 데이터를 검색하는 경우 (예: BETWEEN, >, < 등).
- **정렬된 결과가 필요한 경우**: 쿼리 결과를 정렬해야 하는 경우.
- **데이터의 삽입/삭제가 빈번한 경우**: 균형 잡힌 트리 구조로 인해 이러한 작업이 효율적으로 처리됩니다.

### 6.2. 해시 테이블 Index

#### 개요

- **해시 테이블**은 데이터의 고유 키(Key)를 해싱(Hashing)하여, 해시 함수(Hash Function)에 의해 계산된 인덱스로 데이터를 빠르게 찾는 구조입니다.
- **구조**: 해시 함수에 의해 키가 해시 값으로 변환되고, 이 값을 이용해 데이터가 저장될 위치를 결정합니다.

#### 장점

- **빠른 검색 속도**: 해시 테이블은 키를 바로 해싱하여 데이터를 찾기 때문에 검색 속도가 매우 빠릅니다. 검색, 삽입, 삭제 모두 평균적으로 O(1)의 시간 복잡도를 가집니다.
- **효율적인 단일 레코드 접근**: 특정 레코드에 대한 단일 접근(예: PK 검색)이 매우 빠릅니다.

#### 단점

- **범위 검색 불가**: 해시 테이블은 키-값 매핑을 통해 데이터를 찾기 때문에, 범위 검색이 불가능합니다. (예: BETWEEN, >, < 등의 연산)
- **해시 충돌**: 서로 다른 키가 동일한 해시 값을 가지는 경우 해시 충돌이 발생하며, 이를 처리하기 위한 별도의 메커니즘이 필요합니다(예: 체이닝, 오픈 어드레싱 등).
- **해시 함수 설계**: 해시 함수의 성능에 따라 전체 성능이 좌우되며, 해시 함수가 잘못 설계되면 충돌이 빈번하게 발생하여 성능이 저하될 수 있습니다.

#### 사용하면 좋은 경우

- **단일 값 검색**: 주로 `=` 연산을 통해 단일 레코드를 빠르게 검색해야 하는 경우 (예: Primary Key 검색).
- **데이터가 균일하게 분포된 경우**: 데이터가 고르게 분포되어 있어 해시 충돌이 적은 경우.

## 7. Index 선택 시 고려 사항

- **데이터 액세스 패턴**: 
  - **범위 검색**이 자주 발생하고, 데이터의 순차적 접근이 필요한 경우 B+ Tree를 사용하는 것이 적합합니다.
  - **단일 레코드**에 대한 빠른 접근이 필요하고, 범위 검색이 불필요한 경우 해시 테이블을 사용하는 것이 적합합니다.

- **데이터 수정 빈도**:
  - **빈번한 삽입/삭제** 작업이 필요한 경우, B+ Tree는 균형을 유지하기 때문에 상대적으로 좋은 성능을 발휘합니다.
  - **정적 데이터**에서 특정 값을 빠르게 찾는 작업만 필요한 경우, 해시 테이블이 적합합니다.

- **메모리 사용**: 
  - B+ Tree는 상대적으로 많은 메모리를 사용하나, 다양한 쿼리에서 안정적인 성능을 보장합니다.
  - 해시 테이블은 메모리 사용이 효율적이지만, 범위 쿼리에 제약이 있습니다.


--
## 면접 대비 질문
### 1. B+ Tree와 해시 테이블을 사용한 인덱싱의 차이점은 무엇이며, 각각의 장단점과 사용 사례를 설명해주세요.

- B+ Tree는 범위 검색과 정렬된 데이터 접근에 유리하며, 해시 테이블은 단일 값 검색에서 매우 빠릅니다.
- B+ Tree는 트리 구조로 데이터를 정렬된 상태로 유지하지만, 해시 테이블은 해시 함수를 통해 데이터를 빠르게 검색합니다.
- B+ Tree는 범위 검색이 가능하고, 해시 테이블은 해시 충돌에 주의해야 합니다.
### 2. 인덱스를 사용할 때 주의해야 할 점은 무엇인가요? 특히, 인덱스를 생성하지 말아야 할 경우에 대해 설명해주세요.

- 인덱스는 검색 속도를 높이지만, DML(삽입, 수정, 삭제) 작업이 자주 일어나는 컬럼에 인덱스를 생성하면 성능이 저하될 수 있습니다.
- 데이터 중복도가 높은 컬럼이나 자주 변경되는 컬럼에 인덱스를 생성하면, 오히려 성능 저하가 발생할 수 있습니다.