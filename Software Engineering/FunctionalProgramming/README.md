# 함수형 프로그래밍(Functional Programming)



## 등장

소프트웨어의 복잡성이 증가하면서, 여러 디자인 패턴이 등장하였는데 그 중 대표적인 것이 GoF의 '전략 패턴'이다.

전략 패턴은 `행위`의 유동성을 고려하여 `행위` 자체를 추상화시키는 것이고 이를 통해, `행위`의 확장에 유연하게 대응할 수 있다는 장점이 있다.

"`행위` 자체를 객체로 취급할 수는 없을까?" 라는 생각에서 **함수형 프로그래밍 패러다임**은 시작된다.

함수형 프로그래밍에서는

1. 추상화 가능한 행위를 식별하여 함수화하고
2. 기존 함수를 이용하여 더 복잡한 추상화를 구현하고
3. 기존 함수를 다른 함수의 argument로 넘겨서 더 복잡한 추상화를 구현한다.


> 함수형 프로그래밍은 자료처리를 수학적 함수의 계산으로 취급하고, 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임
> {: .prompt-info}



## 개념

* 순수 함수 (Pure Function)
  * $$x_1 = x_2 \rightarrow f(x_1) = f(x_2)$$ 
    * **항상 동일한 입력에 대해서, 동일한 출력을 보장**

  * 연산의 결과로 **외부 상태**(e.g. 전역변수, 참조변수, 입출력 스트림)을 **변경하지 않는 함수**

* 일급 객체 (First Class Citizen)
  * 변수나 데이터에 할당 가능해야 함
  * 객체의 argument로 넘길 수 있어야 함
  * 객체의 Return 값으로 리턴 가능해야 함
    * 함수를 전달받아서, 이를 리턴할 수 있는 함수를 **고차 함수**(Higher-Order Function) 라고한다.

> 함수형 프로그래밍에서는 순수 함수의 특징을 이용하여 'side-effect' 를 발생시키지 않는 안전성을 얻을 수 있고, 일급 객체의 특징을 이용하여 복잡한 소프트웨어 모듈을 '선언적'으로 구성하도록 도와준다.
> {: .prompt-info}


## 장점

* 선언적(Declarative)인 코드 작성에 유리
  * 내부 동작을 추상화하여 이 함수가 "무엇"을 표현하는지에 초점
  * 수단은 숨기고(추상화하고) 목표를 명시
* 테스팅이 편리하다
  * 외부 상태를 변화시키지 않고 항상 동일한 입력에 대해서 동일한 출력을 내기 떄문
* 동시성/병렬성
  * 외부 상태를 변화시키지 않는다는 점에서 lock에 필요한 오버헤드가 없다

[참고](https://adabeat.com/fp/benefits-of-functional-programming/)

## 단점

* 선언적으로 코드를 구성할 수 있다는 특성으로 인하여, 객체의 상호작용을 이해하기 위해서는 외부 context에 대한 이해를 요구한다.
* 성능 상의 오버헤드가 존재할 수 있다
  * `lazy evaluation`을 적용한다고 해도, 실제 리소스의 사용량을 예측하기 어렵다.
  * 데이터 변경이 필요할 경우 복사본을 전달하는 방식으로 구현되어야한다.











